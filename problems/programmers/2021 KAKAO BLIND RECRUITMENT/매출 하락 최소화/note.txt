1번부터 차례대로 참석/불참으로 분기 나누어 탐색
1. 이미 모든 팀에서 한 명 이상 참석했다면
  => 더 참석하면 반드시 매출 하락이 늘어나므로 탐색 중지
2. 전원이 불참한 팀이 존재한다면
  => 불가능한 케이스이므로 마찬가지로 탐색 중지, 최댓값 반환
3. 참석하는 경우와 불참하는 경우 중 더 적은 매출 하락폭을 반환

=> 절반 정도에서 시간초과

왜?
1. 나름 pruning을 하기는 했지만 탐색 공간이 너무 넓다
2. 조직 구조와는 무관하게 번호순으로 탐색하다 보니 서브트리를 다시 계산하는 횟수가 많았을 것

굳이 팀 구조가 트리가 되도록 줬으니 그 구조 기반으로, 팀 단위로 쪼개서 풀어보자
문제의 답은 가장 상위 팀 팀장(1번)이 참석할 때의 최솟값과 불참할 때의 최솟값 중 작은 쪽

팀별로 보면?
팀장이 참석할 때의 최솟값: 팀장의 매출 + 팀원들의 참/불참에 따른 매출 하락 최소의 합
* 이미 팀장이 참석하므로 팀원이 모두 불참해도 무관
팀장이 불참할 때의 최솟값: 팀원들의 참/불참에 따른 매출 하락 최소의 합
* 단, 팀장이 불참한 경우 팀원 모두가 불참하는 것은 안됨
팀원이 모두 불참하는 경우라면 참석했을 때 가장 손해가 적은 팀원을 참석시켜야 하므로
해당 팀원의 참/불참간의 차만큼 더해줘야 함 (불참시 손해만큼은 이미 더해져 있음)

=> 좀 더 빨라졌지만 아직 시간초과

왜? 아직도 중복 계산이 있나? => 없다. 전역으로 값을 기록하지는 않지만 형제 트리?의 값은 필요없으니 상관없음
그렇다면 계산 자체가 느린가? => sort, reduce 등 foreach 안에서 해결해보자

=> 눈곱만큼 빨라졌다

그럼 어디서 시간을 많이 쓰나? 남은 건 트리 구성단계밖에 없다
links를 따라서 트리를 구성하다 보면 끊어져 있다가 나중에 연결되는 부분이 있었음
무지성으로 당장 연결할 수 없는 link는 맨 뒤로 미루면서 모든 link가 연결될 때까지 while을 돌림
=> link가 30만개까지도 생기는데, shift, push 시간 + 연결 가능한 link까지 돌리는 시간까지 하면 정말 오래 걸렸을 듯

더 빠르게 트리를 구성할 방법?
굳이 실제로 트리를 만들 필요가 있나?
그냥 처음 했던 대로 각 팀의 정보만 만들어서 모아 두자

=> 정답