첫인상: 일단 각 시험장 id에 대해서 서브트리의 합을 계산해두면 될 것 같다

어떤 간선을 끊는 게 가장 이득인가?
=> 모든 간선 중에서 하위에 딸린 응시자가 가장 많은 간선부터 끊는 것이 이득

...이 아닌 것 같다
최적보다 위쪽에서 끊기게 될 것
간선을 선택해서 끊는 게 생각보다 어려운 문제인 듯

이것도 파라메트릭 서치로 접근해야 하나 봄

그룹 최대 크기를 n으로 제한하고 그룹들을 구성했을 때
그룹 수가 k개 이하이다 -> n값을 감소
그룹 수가 k개를 초과한다 -> n값을 증가
하면서 최대의 n을 찾으면 됨

시험장 최대 10,000개, 각 시험장당 최대 10,000명
최악의 케이스에서 n => 10,000 * 10,000 = 100,000,000
log2(100,000,000) => 약 27번 안에 계산 가능
실제로는 num 최댓값이 n 최솟값, num의 합이 n의 최댓값

최대 크기를 제한하면서 어떻게 그룹을 구성할 것인가?
일단 root를 찾고 dfs해 보자

leaf까지 내려갔다가 올라오면서
1. 부모+자식 모두 포함해도 그룹 크기 이내: 그대로 진행
2. 왼쪽 자식을 포함하면 크기 초과: 왼쪽을 자르기
3. 오른쪽 자식을 포함하면 크기 초과: 오른쪽을 자르기
4. 둘 다 포함할 때만 크기 초과: 양쪽 서브트리 중 크기가 큰 쪽을 자르기
=> 그룹 크기 탐색 범위의 최솟값을 num 중 최댓값으로 잡았으므로 부모 하나만으로도 제한을 넘는 경우는 없다

효율성 테스트에서 시간초과 + 런타임에러 다수 발생
root를 구하는 방식이 너무 비효율적인 것 같다
다른 모든 link에 포함되지 않는 index를 찾기 (n^2) -> links를 순회하며 등장했던 index를 지우고 남은 것을 찾기 (n)

런타임 에러만 남았다. 아마 호출 스택 초과일 듯
재귀 -> 반복으로 바꿔보자

드디어 해결...