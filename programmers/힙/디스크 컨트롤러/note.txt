우선 우선순위를 정하는 기준 -> 만약 요청이 들어온 시점과 소요시간이 같다면 ID를 기준으로 정렬하라고는 하지만,
결국 요구되는 답은 각각의 반환 시간이 아닌 전체 반환 시간의 평균이므로, 요청 시점과 소요시간이 모두 같으면 둘 중 무엇을 먼저 처리하든 답에는 영향이 없음.
따라서 ID는 별도로 저장/관리할 필요가 없음.

작업의 우선순위를 정해야 하는 문제이므로, 자연스럽게 우선순위큐가 필요. heapq를 이용하여 구현.
Python 내장 heapq는 기본적으로 tuple을 받을 경우 tuple의 첫 번째 원소만을 비교하므로, 작업의 소요 시간과 요청 시점을 모두 비교하기 위해 클래스와 __lt__매직메서드를 정의.

1. 0초부터 시작하여 작업 큐에 작업이 있으면 큐에서 작업을 꺼내고, 그렇지 않으면 요청 목록에서 작업을 꺼내면 됨.
- 큐에서 작업을 꺼냈다는 것은 해당 작업이 과거에 요청되었다는 뜻이고, 요청 목록에서 꺼냈다는 것은 아직 요청되지 않은 미래의 작업이라는 뜻.
- 따라서 요청 목록에서 꺼낸 경우 해당 작업의 요청 시간으로 현재 시간을 업데이트.
2. 작업의 소요 시간만큼 현재 시간에 더해주고, 현재 시간과 작업의 요청 시간의 차(=반환 시간)을 기록
3. 해당 작업을 하는 동안 지나간 요청들을 큐에 담기 위해 요청 목록에서 과거 시점의 요청들을 모두 큐에 담음.
큐와 요청 목록이 모두 빌 때까지 1~3를 반복하고 반환 시간의 평균을 구하면 끝.