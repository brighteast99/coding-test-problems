처음에는 메모이제이션을 사용한 DFS로 풀어볼 생각이었다.
N은 N 하나로, 1은 N 두 개로 표현 가능하므로 이를 베이스 케이스로 두고,
number를 (number - 1) - 1, (number + 1) - 1, (number - N) + N, (number + N) - N, (number * N) / N, (numer / N) * N으로 쪼개자는 아이디어였다.
그러나 우선 불필요한 분기가 너무 많아 시간도 오래 걸렸고, 이런 식으로 가면 N뿐 아니라 NN, NNN, ...을 더하거나 빼거나 곱하는 경우들도 고려해야 하므로 사실상 불가능하다고 느꼈다.
결국 힌트를 찾아다녔고, 접근이 잘못되었음을 깨달았다.
number에서 출발해서 수를 변형하는 것이 아니라 N을 i번 사용해서 만들 수 있는 숫자들을 구하고, i를 늘리면서 만들 수 있는 숫자의 범위를 확장하는 것이다.
이렇게 하면 N을 8번 이상 사용해야 만들 수 있는 숫자의 경우 -1을 반환하라는 문제의 조건도 명확하게 구현이 가능하다.
