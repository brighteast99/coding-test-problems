결국 일부 구간의 최댓값들을 이용하여 전체의 최댓값을 구해야 하는 문제일 것.
탑다운식으로 생각해 보면 숫자의 개수가 n개일 때

0번 수와 1번~n번의 최댓값
0~1번의 최댓값과 2~n번의 최댓값
0~2번의 최댓값과 3~n번의 최댓값
...
중 최대가 답이 될 것.

그런데, 연산 중 -가 존재하고, 이 경우 앞의 숫자를 최대화, 뒤의 숫자를 최소화해야 함.
즉, 구간별 최솟값도 같이 저장해야 한다는 의미.

0번과 1번 사이 연산이 +인 경우
0번 + 1~n번의 최댓값
-인 경우
0번 - 1~n번의 최솟값
같은 형태.

평소같으면 memoization을 이용한 탑다운 풀이를 했겠지만, 도둑질 문제처럼 재귀 깊이에 걸릴 것 같으므로 바텀업 방식으로 풀기어 보기로 결정.
베이스 케이스는 구간의 크기가 1인 경우로, 최댓값과 최솟값 모두 해당 숫자가 됨.