보드를 기울이는 로직만 구현하면 빨간 공만 구멍에 넣는 가장 빠른 방법을 찾는 것은 쉬운 문제.

일단 구슬의 위치를 매번 보드를 탐색하여 찾는 것은 비효율적이기도 하고, 탐색시 각 경우의 수마다 보드 전체를 복사해서 스택에 쌓아줘야 하는 문제도 있으므로,
보드에는 벽과 구멍의 위치만 남겨 공유하고, 빨강/파랑 구슬의 위치만 별도의 상태로 저장해 가며 탐색하기로 함

구슬은 서로에게 영향을 줌. 아무 구슬이나 먼저 굴리면 두 구슬 모두 더이상 움직이지 않을 때까지 계속 반복해야 하는 비효율 발생
예를 들어 #.RB# 상태에서 왼쪽으로 보드를 기울일 때, 파란색을 항상 먼저 굴린다고 하면
1. 파랑이 빨강에 막히고, 빨강은 굴러감
2. 빨강이 움직였으므로 파랑도 움직일 수 있게 되었을 가능성 존재. 한 번 더 굴림
3. 파랑이 한 칸 굴러가 빨강에게 막히고, 빨강은 벽에 막힘
4. 파랑이 움직였으므로 빨강도 움직일 수 있게 되었을 가능성 존재. 한 번 더 굴림
5. 파랑, 빨강 모두 움직이지 않았으므로, 기울이기를 멈춤
빨강을 항상 먼저 굴린다면 한 번에 끝나겠지만, 좌우 반전된 상황을 가정하면 마찬가지의 현상 발생.
=> 따라서 구슬이 앞선 다른 구슬에 막힐 여지가 있다면, 그 구슬을 나중에 굴리는 로직이 필요

기본적으로 항상 빨강을 먼저 굴리되,
두 구슬이 같은 열에 있을 때, 파랑이 더 위에 있을 때 위쪽으로/더 아래에 있을 때 아래쪽으로 굴려야 하거나
두 구슬이 같은 행에 있을 때, 파랑이 더 왼쪽에 있을 때 왼쪽으로/더 오른쪽에 있을 때 오른쪽으로 굴려야 하는 경우
순서를 바꿔 파랑을 먼저 굴리도록 함
이때 앞서 굴린 구슬이 구멍으로 빠진 경우, 그 구슬은 무시해야 함

가장 빠른 방법을 찾는 것이므로 BFS가 DFS보다 빠를 것이라는 예상과 달리..
각 상태별로 그 상태에 도달하기 위한 최소 기울임 수를 저장하여 pruning하며 진행한 DFS가 시간과 메모리 모두 적게 사용하였음...